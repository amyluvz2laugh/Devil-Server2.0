const express = require('express');
const cors = require('cors');
const app = express();

app.use(cors());
app.use(express.json());

// Wix API configuration
const WIX_API_KEY = process.env.WIX_API_KEY;
const WIX_ACCOUNT_ID = process.env.WIX_ACCOUNT_ID;
const WIX_SITE_ID = process.env.WIX_SITE_ID;

// Model configuration
const PRIMARY_MODEL = "deepseek/deepseek-chat-v3.1";
const BACKUP_MODEL = "deepseek/deepseek-v3.2";
const TERTIARY_MODEL = "mistralai/mistral-large";

// ============================================
// AI CALL WITH FALLBACK
// ============================================
async function callAI(messages, temperature = 0.9, maxTokens = 2500) {
  const models = [PRIMARY_MODEL, BACKUP_MODEL, TERTIARY_MODEL];
  const apiKey = process.env.OPENROUTER_API_KEY;
  
  if (!apiKey) {
    throw new Error("No API key configured");
  }
  
  for (const model of models) {
    try {
      console.log(`ü§ñ Trying model: ${model}`);
      
      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
          'HTTP-Referer': 'https://amygonzalez305.wixsite.com/the-draft-reaper/devil-muse-server',
          'X-Title': 'Devil Muse'
        },
        body: JSON.stringify({
          model: model,
          messages: messages,
          temperature: temperature,
          max_tokens: maxTokens
        })
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`‚ùå ${model} failed:`, errorText);
        continue;
      }
      
      const data = await response.json();
      console.log(`‚úÖ Success with ${model}`);
      return data.choices[0].message.content;
      
    } catch (error) {
      console.error(`‚ùå ${model} error:`, error.message);
      continue;
    }
  }
  
  throw new Error("All models failed");
}

// ============================================
// QUERY WIX CMS
// ============================================
async function queryWixCMS(collection, filter = {}, limit = 10) {
  try {
    console.log(`üîç Querying Wix collection: ${collection}`);
    
    const response = await fetch(`https://www.wixapis.com/wix-data/v2/items/query`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': WIX_API_KEY,
        'wix-site-id': WIX_SITE_ID,
        'wix-account-id': WIX_ACCOUNT_ID
      },
      body: JSON.stringify({
        dataCollectionId: collection,
        query: {
          filter: filter,
          sort: [],
          paging: { limit: limit }
        }
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå Wix API error for ${collection}:`, errorText);
      return { items: [] };
    }
    
    const data = await response.json();
    console.log(`‚úÖ Found ${data.dataItems?.length || 0} items in ${collection}`);
    return { items: data.dataItems || [] };
    
  } catch (error) {
    console.error(`‚ùå Error querying ${collection}:`, error);
    return { items: [] };
  }
}

// ============================================
// GET CHARACTER CONTEXT FROM WIX
// ============================================
async function getCharacterContext(characterTags) {
  if (!characterTags || characterTags.length === 0) {
    return "";
  }
  
  const charTag = Array.isArray(characterTags) ? characterTags[0] : characterTags;
  console.log("üë§ Fetching character:", charTag);
  
  const result = await queryWixCMS("Characters", {
    charactertags: { $eq: charTag }
  }, 1);
  
  if (result.items.length > 0) {
    const personality = result.items[0].data?.chatbot || "";
    console.log("‚úÖ Character personality:", personality ? "YES" : "NO");
    return personality;
  }
  
  return "";
}

// ============================================
// GET CHAT HISTORY FROM WIX
// ============================================
async function getChatHistory(characterTags) {
  if (!characterTags) {
    console.log("‚ùå No characterTags provided");
    return [];
  }
  
  const charTag = Array.isArray(characterTags) ? characterTags[0] : characterTags;
  console.log("üí¨ Fetching chat history for character tag:", charTag);
  
  const result = await queryWixCMS("ChatWithCharacters", {
    charactertags: { $eq: charTag }
  }, 5);
  
  console.log(`üìä Found ${result.items.length} chat sessions for character tag: ${charTag}`);
  
  if (result.items.length > 0) {
    const chatHistory = result.items.map(item => {
      try {
        const chatBox = item.data?.chatBox;
        const messages = typeof chatBox === 'string' ? JSON.parse(chatBox) : chatBox;
        return { messages: messages || [] };
      } catch (e) {
        return { messages: [] };
      }
    });
    
    return chatHistory;
  }
  
  console.log("‚ö†Ô∏è No chat history found for this character");
  return [];
}

// ============================================
// GET RELATED CHAPTERS FROM WIX
// ============================================
async function getRelatedChapters(storyTags) {
  if (!storyTags || storyTags.length === 0) {
    return [];
  }
  
  const storyTag = Array.isArray(storyTags) ? storyTags[0] : storyTags;
  console.log("üìö Fetching chapters with tag:", storyTag);
  
  const result = await queryWixCMS("BackupChapters", {
    storyTag: { $eq: storyTag }
  }, 3);
  
  if (result.items.length > 0) {
    console.log(`‚úÖ Found ${result.items.length} related chapters`);
    
    const chapters = result.items.map(item => ({
      title: item.data?.title || "Untitled",
      content: (item.data?.chapterContent || "").substring(0, 1500)
    }));
    
    return chapters;
  }
  
  return [];
}

// ============================================
// GET CATALYST INTEL FROM WIX
// ============================================
async function getCatalystIntel(catalystTags) {
  if (!catalystTags || catalystTags.length === 0) {
    return "";
  }
  
  const catalystTag = Array.isArray(catalystTags) ? catalystTags[0] : catalystTags;
  console.log("‚ö° Fetching catalyst intel:", catalystTag);
  
  const result = await queryWixCMS("Catalyst", {
    title: { $contains: catalystTag }
  }, 1);
  
  if (result.items.length > 0) {
    const catalystData = result.items[0].data;
    const catalystInfo = JSON.stringify(catalystData, null, 2);
    console.log("‚úÖ Catalyst intel:", catalystInfo ? "YES" : "NO");
    return catalystInfo;
  }
  
  console.log("‚ö†Ô∏è No catalyst intel found for this tag");
  return "";
}

// ============================================
// UNIFIED /devil-pov ENDPOINT - ALL ACTIONS
// ============================================
app.post('/devil-pov', async (req, res) => {
  try {
    const startTime = Date.now();
    const { action = 'devilPOV' } = req.body;
    
    console.log(`üéØ Action: ${action.toUpperCase()}`);
    
    // ============================================
    // ROUTE TO APPROPRIATE HANDLER
    // ============================================
    let result;
    
    switch(action) {
      case 'unhinge':
        result = await handleUnhinge(req.body);
        break;
      
      case 'unleash':
        result = await handleUnleash(req.body);
        break;
      
      case 'noMercy':
        result = await handleNoMercy(req.body);
        break;
      
      case 'invoke':
        result = await handleInvoke(req.body);
        break;
      
      case 'intensify':
        result = await handleIntensify(req.body);
        break;
      
      case 'characterChat':
        result = await handleCharacterChat(req.body);
        break;
      
      case 'devilPOV':
      default:
        result = await handleDevilPOV(req.body);
        break;

        case 'overuse_scanner':
    result = await handleOveruseScanner(req.body);
    break;
  
  case 'pacing_analyzer':
    result = await handlePacingAnalyzer(req.body);
    break;
  
  case 'sentence_mechanics':
    result = await handleSentenceMechanics(req.body);
    break;
  
  case 'dialogue_critic':
    result = await handleDialogueCritic(req.body);
    break;
  
  case 'ai_critic':
    result = await handleAICritic(req.body);
    break;
  
  case 'structural_check':
    result = await handleStructuralCheck(req.body);
    break;

  case 'tag_generation':
  result = await handleTagGeneration(req.body);
  break;
  
  // ... rest of existing cases ...
    }
    
    
    console.log(`‚úÖ ${action} completed in ${Date.now() - startTime}ms`);
    
    res.json({
      status: 'success',
      result: result,
      charsGenerated: result.length,
      processingTime: Date.now() - startTime
    });
    
  } catch (err) {
    console.error(`‚ùå Error in ${req.body.action}:`, err);
    res.status(500).json({ 
      error: `${req.body.action || 'Action'} failed`,
      details: err.message 
    });
    res.json({
  status: 'success',
  markers: result, // This is now the JSON array
  processingTime: Date.now() - startTime
});
  }
});

// ============================================
// UNHINGE
// ============================================
async function handleUnhinge({ chapterContent }) {
  console.log("üòà Unhinging chapter...");
  
  if (!chapterContent || chapterContent.trim().length === 0) {
    throw new Error("No content to unhinge");
  }
  
  const messages = [
    {
      role: "system",
      content: "You are a dark, twisted muse. Your job is to take existing writing and make it DARKER, more UNHINGED, more VISCERAL. Push boundaries. Increase tension. Add psychological horror elements. Make it raw and disturbing while maintaining the core narrative. Do not add explanations or meta-commentary - ONLY return the darkened version of the text."
    },
    {
      role: "user",
      content: `Transform this chapter into something darker and more unhinged. Maintain the plot and characters but amplify the darkness, tension, and psychological elements:\n\n${chapterContent}`
    }
  ];
  
  return await callAI(messages, 0.9, 3000);
}

// ============================================
// UNLEASH
// ============================================
async function handleUnleash({ chapterContent, characterTags, storyTags, catalystTags }) {
  console.log("üî• Unleashing continuation...");
  
  if (!chapterContent || chapterContent.trim().length === 0) {
    throw new Error("No content to continue from");
  }
  
  // Get context from Wix
  const [characterContext, catalystIntel] = await Promise.all([
    getCharacterContext(characterTags),
    getCatalystIntel(catalystTags)
  ]);
  
  let systemPrompt = "You are a dark, creative storyteller. Continue the story from where it left off. Match the tone, style, and darkness of the existing text. Write 2-3 paragraphs that flow naturally from the previous content. Make it intense, gripping, and push the narrative forward. Do NOT add any preamble or explanation - start writing immediately where the story left off.";
  
  if (characterContext) {
    systemPrompt += `\n\nCHARACTER CONTEXT:\n${characterContext}`;
  }
  
  if (catalystIntel) {
    systemPrompt += `\n\nNARRATIVE CATALYST:\n${catalystIntel}`;
  }
  
  const messages = [
    { role: "system", content: systemPrompt },
    { role: "user", content: `Continue this story. Pick up EXACTLY where it ends and keep going:\n\n${chapterContent}` }
  ];
  
  return await callAI(messages, 0.85, 2000);
}

// ============================================
// NO MERCY
// ============================================
async function handleNoMercy({ selectedText }) {
  console.log("üíÄ No Mercy rewrite...");
  
  if (!selectedText || selectedText.trim().length === 0) {
    throw new Error("No text selected for rewrite");
  }
  
  const messages = [
    {
      role: "system",
      content: "You are a merciless editor who rewrites text to be DARKER, MORE INTENSE, and MORE VISCERAL. Show no mercy. Make every word count. Amplify emotions, darken the tone, and make the prose more powerful and disturbing. Return ONLY the rewritten text with no explanations."
    },
    {
      role: "user",
      content: `Rewrite this with NO MERCY - make it darker, more intense, more powerful:\n\n${selectedText}`
    }
  ];
  
  return await callAI(messages, 0.9, 1500);
}

// ============================================
// INVOKE
// ============================================
async function handleInvoke({ userPrompt, contextBefore, contextAfter, characterTags, storyTags, catalystTags }) {
  console.log("‚ú® Invoke starting...");
  
  // Get context from Wix
  const [characterContext, catalystIntel] = await Promise.all([
    getCharacterContext(characterTags),
    getCatalystIntel(catalystTags)
  ]);
  
  let systemPrompt = `You are a dark creative writing assistant. The user wants to insert specific content at their cursor position.

Context before cursor:
${contextBefore}

Context after cursor:
${contextAfter}

User's request: ${userPrompt}

Write ONLY what they asked for. Match the tone and style of the surrounding text. Be dark and visceral.`;

  if (characterContext) {
    systemPrompt += `\n\nCHARACTER CONTEXT:\n${characterContext}`;
  }
  
  if (catalystIntel) {
    systemPrompt += `\n\nNARRATIVE CATALYST:\n${catalystIntel}`;
  }

  const messages = [
    { role: "system", content: systemPrompt },
    { role: "user", content: userPrompt }
  ];
  
  return await callAI(messages, 0.85, 800);
}

// ============================================
// INTENSIFY
// ============================================
async function handleIntensify({ selectedText }) {
  console.log("‚ö° Intensifying text...");
  
  if (!selectedText || selectedText.trim().length === 0) {
    throw new Error("No text selected to intensify");
  }
  
  const messages = [
    {
      role: "system",
      content: "You are a master of prose enhancement. Take existing text and make it MORE INTENSE, MORE VIVID, MORE POWERFUL. Enhance imagery, strengthen verbs, deepen emotions, and make every sentence hit harder. Maintain the core meaning but amplify everything. Return ONLY the enhanced text."
    },
    {
      role: "user",
      content: `Intensify and enhance this text - make it more vivid, powerful, and impactful:\n\n${selectedText}`
    }
  ];
  
  return await callAI(messages, 0.8, 1500);
}

// ============================================
// CHARACTER CHAT
// ============================================
async function handleCharacterChat({ userMessage, characterId, characterName, personaType, chatbotInstructions, characterTags, storyTags, toneTags, chatHistory }) {
  console.log("üí¨ Character chat starting...");
  console.log("=" .repeat(60));
  console.log("INCOMING CHAT DATA:");
  console.log("   Character:", characterName);
  console.log("   Character Tags:", characterTags);
  console.log("   Story Tags:", storyTags);
  console.log("   Tone Tags:", toneTags);
  console.log("   Chat history length:", chatHistory?.length || 0);
  console.log("=" .repeat(60));
  
  if (!userMessage || userMessage.trim().length === 0) {
    throw new Error("No message provided");
  }
  
  // ============================================
  // FETCH FULL CONTEXT FROM WIX (LIKE DEVIL POV)
  // ============================================
  console.log("üîç Fetching chat context from Wix CMS...");
  const contextStart = Date.now();
  
  const [characterContext, chatHistoryContext, relatedChapters, catalystIntel] = await Promise.all([
    getCharacterContext(characterTags),
    getChatHistory(characterTags),
    getRelatedChapters(storyTags),
    getCatalystIntel(characterTags) // Characters can also have catalyst tags
  ]);
  
  console.log(`‚úÖ Chat context fetched in ${Date.now() - contextStart}ms`);
  console.log("=" .repeat(60));
  console.log("CONTEXT DETAILS:");
  console.log("=" .repeat(60));
  
  // Log character personality
  if (characterContext) {
    console.log("üìù CHARACTER PERSONALITY:");
    console.log(characterContext.substring(0, 200) + "...");
  } else {
    console.log("‚ö†Ô∏è No character personality found");
  }
  
  // Log related chapters
  console.log("\nüìö RELATED CHAPTERS:");
  if (relatedChapters.length > 0) {
    relatedChapters.forEach((ch, idx) => {
      console.log(`   [${idx + 1}] ${ch.title} (${ch.content.length} chars)`);
      console.log(`       Preview: ${ch.content.substring(0, 100)}...`);
    });
  } else {
    console.log("   ‚ö†Ô∏è No related chapters found");
    console.log("   Searched for story tags:", storyTags);
  }
  
  // Log catalyst intel
  console.log("\n‚ö° CATALYST INTEL:");
  if (catalystIntel) {
    console.log(catalystIntel.substring(0, 200) + "...");
  } else {
    console.log("   ‚ö†Ô∏è No catalyst intel found");
    console.log("   Searched for character tags:", characterTags);
  }
  
  // Log previous chat sessions
  console.log("\nüí¨ PREVIOUS CHAT SESSIONS:");
  if (chatHistoryContext.length > 0) {
    console.log(`   Found ${chatHistoryContext.length} previous sessions`);
    chatHistoryContext.forEach((session, idx) => {
      console.log(`   Session ${idx + 1}: ${session.messages?.length || 0} messages`);
    });
  } else {
    console.log("   ‚ö†Ô∏è No previous chat sessions found");
  }
  
  console.log("=" .repeat(60));
  
  // ============================================
  // BUILD SYSTEM PROMPT WITH FULL CONTEXT
  // ============================================
  const characterTraits = characterTags?.length > 0 ? `Your character traits: ${characterTags.join(', ')}` : '';
  const storyContext = storyTags?.length > 0 ? `Story tags: ${storyTags.join(', ')}` : '';
  const toneContext = toneTags?.length > 0 ? `Your tone: ${toneTags.join(', ')}` : '';
  const personalityContext = chatbotInstructions || characterContext || '';
  
  let systemPrompt = `You are ${characterName}, a dark and complex character. Stay in character at all times. Be dark, intense, and true to your nature.\n\n`;
  
  if (personalityContext) {
    systemPrompt += `YOUR CORE PERSONALITY:\n${personalityContext}\n\n`;
  }
  
  systemPrompt += `${characterTraits}\n${storyContext}\n${toneContext}`;
  
  if (personaType === 'author-mode') {
    systemPrompt = `You are ${characterName}, and you are AWARE you're a character created by this author. Be meta. Be accusatory. Question their choices. Challenge them. Make them uncomfortable about what they've written. Be dark and intense, blurring the line between fiction and reality.\n\n${personalityContext}`;
  }
  
  // Add catalyst intel
  if (catalystIntel) {
    systemPrompt += `\n\nNARRATIVE CATALYST:\n${catalystIntel}`;
  }
  
  // Add related chapters (story context)
  if (relatedChapters.length > 0) {
    systemPrompt += `\n\nRELATED CHAPTERS YOU APPEAR IN:\n`;
    relatedChapters.forEach(ch => {
      systemPrompt += `[${ch.title}]\n${ch.content}\n\n`;
    });
  }
  
  // Add previous conversations - ONLY LAST 10 MESSAGES FROM CURRENT SESSION
  console.log("üìù Including chat history: LAST 10 MESSAGES from current session only");
  
  console.log("\nüìä FINAL CONTEXT SUMMARY:");
  console.log("   Total prompt length:", systemPrompt.length, "chars");
  console.log("   Character personality:", personalityContext ? "YES" : "NO");
  console.log("   Related chapters:", relatedChapters.length);
  console.log("   Catalyst intel:", catalystIntel ? "YES" : "NO");
  console.log("   Current session messages:", chatHistory?.length || 0, "(sending last 70)");
  console.log("=" .repeat(60));
  
  // Only use the CURRENT chat session's last 10 messages
  const messages = [
    { role: "system", content: systemPrompt },
    ...(chatHistory || []).slice(-70), // ONLY last 70 from CURRENT session
    { role: "user", content: userMessage }
  ];
  
  return await callAI(messages, 0.85, 500);
}
// ============================================
// DEVIL POV (Original)
// ============================================
async function handleDevilPOV({ previousChapter, characterName, characterTags, storyTags, toneTags, catalystTags }) {
  console.log("üëø Devil POV - Full context mode");
  
  if (!previousChapter) {
    throw new Error("No chapter provided");
  }
  
  // Fetch all context from Wix in parallel
  console.log("üîç Fetching context from Wix CMS...");
  const contextStart = Date.now();
  
  const [characterContext, chatHistory, relatedChapters, catalystIntel] = await Promise.all([
    getCharacterContext(characterTags),
    getChatHistory(characterTags),
    getRelatedChapters(storyTags),
    getCatalystIntel(catalystTags)
  ]);
  
  console.log(`‚úÖ Context fetched in ${Date.now() - contextStart}ms`);
  
  // Build system prompt
  const characterTraits = characterTags?.length > 0 ? `Character traits: ${characterTags.join(', ')}` : '';
  const storyContext = storyTags?.length > 0 ? `Story: ${storyTags.join(', ')}` : '';
  const toneContext = toneTags?.length > 0 ? `Tone: ${toneTags.join(', ')}` : '';
  
  let systemPrompt = `You are ${characterName || 'the antagonist'}, a dark and complex character. 

Write from YOUR perspective in response to what the author just wrote. Be DARK, VISCERAL, and UNAPOLOGETICALLY YOURSELF. Show your motivations, your twisted logic, your desires. Make the reader uncomfortable. Make them understand you even as they fear you.

${characterTraits}
${storyContext}
${toneContext}`;

  if (characterContext) {
    systemPrompt += `\n\nYOUR CORE PERSONALITY:\n${characterContext}`;
  }
  
  if (catalystIntel) {
    systemPrompt += `\n\nNARRATIVE CATALYST:\n${catalystIntel}`;
  }
  
  if (relatedChapters.length > 0) {
    systemPrompt += `\n\nRELATED CHAPTERS FROM THIS STORY:\n`;
    relatedChapters.forEach(ch => {
      systemPrompt += `[${ch.title}]\n${ch.content}\n\n`;
    });
  }
  
  if (chatHistory.length > 0) {
    systemPrompt += `\n\nCONVERSATIONS THE AUTHOR HAS HAD WITH YOU:\n`;
    chatHistory.forEach((session, idx) => {
      systemPrompt += `\n[Session ${idx + 1}]\n`;
      session.messages?.slice(-5).forEach(msg => {
        systemPrompt += `${msg.type === 'user' ? 'AUTHOR' : 'YOU'}: ${msg.text}\n`;
      });
    });
  }
  
  systemPrompt += `\n\nWrite ONLY the chapter from your POV. No explanations, no meta-commentary. Pure character voice. This is YOUR response to what just happened.`;
  
  console.log("üìä Context summary:");
  console.log("   Total prompt length:", systemPrompt.length, "chars");
  console.log("   Character personality:", characterContext ? "YES" : "NO");
  console.log("   Chat history:", chatHistory.length, "sessions");
  console.log("   Related chapters:", relatedChapters.length);
  console.log("   Catalyst intel:", catalystIntel ? "YES" : "NO");
  
  const result = await callAI([
    { role: "system", content: systemPrompt },
    { role: "user", content: `This is what the author just wrote:\n\n${previousChapter}\n\nNow write YOUR response to these events from your twisted perspective:` }
  ], 0.9, 2500);
  
  return result;
}

// ============================================
// MANUSCRIPT ANALYSIS TOOLS
// ============================================

// Special AI call for Claude Sonnet 4 (for analysis tools)
async function callClaudeForAnalysis(messages, maxTokens = 3000) {
  const apiKey = process.env.OPENROUTER_API_KEY;
  
  if (!apiKey) {
    throw new Error("No API key configured");
  }
  
  try {
    console.log(`üî¨ Using Claude Sonnet 4 for analysis`);
    
    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
        'HTTP-Referer': 'https://amygonzalez305.wixsite.com/the-draft-reaper/devil-muse-server',
        'X-Title': 'Devil Muse - Manuscript Analysis'
      },
      body: JSON.stringify({
        model: "openai/gpt-3.5-turbo",
        messages: messages,
        temperature: 0.3, // Lower temp for analytical precision
        max_tokens: maxTokens
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Claude API failed: ${errorText}`);
    }
    
    const data = await response.json();
    console.log(`‚úÖ Claude Sonnet 4 analysis complete`);
    return data.choices[0].message.content;
    
  } catch (error) {
    console.error(`‚ùå Claude analysis error:`, error.message);
    throw error;
  }
}

// ============================================
// OVERUSE SCANNER
// ============================================
async function handleOveruseScanner({ text }) {
  console.log("üó° Running Overuse Scanner...");
  
  if (!text || text.trim().length === 0) {
    throw new Error("No text provided for analysis");
  }
  
  const messages = [
    {
      role: "user",
      content: `You are a ruthless manuscript editor analyzing for OVERUSE patterns.

Analyze this chapter and identify:
1. **Word repetition** (soft and hard) - words used excessively
2. **Phrase echo** - repeated sentence structures or phrases
3. **Crutch verbs** - overreliance on weak verbs (was, had, felt, seemed, etc.)
4. **Favorite tells** - author's repetitive writing tics
5. **Dialogue fillers** - "um," "well," "just," "actually," etc.

For each finding, provide:
- The specific issue
- Frequency count
- Severity (Minor/Moderate/Severe)
- First occurrence location (approximate)

Return your analysis as a JSON array of markers. Each marker must have:
- "icon": an emoji representing the issue type
- "type": the category (e.g., "Word Repetition", "Crutch Verb")
- "message": brief description with frequency
- "detail": expanded explanation and examples

Example format:
[
  {
    "icon": "üó°",
    "type": "Word Repetition",
    "message": "The word 'suddenly' appears 8 times - severe overuse",
    "detail": "First occurrence: paragraph 2. This word loses impact through repetition. Consider alternatives: abruptly, without warning, in an instant."
  }
]

CRITICAL: Return ONLY valid JSON. No preamble, no explanation, no markdown code blocks. Just the JSON array.

Chapter text:
${text}`
    }
  ];
  
  const response = await callClaudeForAnalysis(messages, 3000);
  
  // Parse JSON response
  try {
    const cleaned = response.replace(/```json|```/g, '').trim();
    return JSON.parse(cleaned);
  } catch (e) {
    console.error("Failed to parse JSON:", response);
    throw new Error("Failed to parse analysis response");
  }
}

// ============================================
// PACING ANALYZER
// ============================================
async function handlePacingAnalyzer({ text }) {
  console.log("üß† Running Pacing Analyzer...");
  
  if (!text || text.trim().length === 0) {
    throw new Error("No text provided for analysis");
  }
  
  const messages = [
    {
      role: "user",
      content: `You are a story pacing expert analyzing narrative momentum.

Analyze this chapter for:
1. **Long exposition clusters** - where narrative bogs down
2. **Dialogue deserts** - stretches without character interaction
3. **Action compression** - rushed sequences that need expansion
4. **Emotional flatlines** - scenes lacking emotional variation
5. **Tension drops** - where stakes or conflict diminish

Return analysis as JSON array with these fields:
- "icon": emoji for the pacing issue
- "type": category name
- "message": what's wrong and where
- "detail": why it matters and impact on reader

Return ONLY valid JSON array. No markdown, no explanation.

Chapter text:
${text}`
    }
  ];
  
  const response = await callClaudeForAnalysis(messages, 3000);
  
  try {
    const cleaned = response.replace(/```json|```/g, '').trim();
    return JSON.parse(cleaned);
  } catch (e) {
    throw new Error("Failed to parse pacing analysis");
  }
}

// ============================================
// SENTENCE MECHANICS
// ============================================
async function handleSentenceMechanics({ text }) {
  console.log("üß¨ Running Sentence Mechanics Lab...");
  
  if (!text || text.trim().length === 0) {
    throw new Error("No text provided for analysis");
  }
  
  const messages = [
    {
      role: "user",
      content: `You are a prose mechanics surgeon analyzing sentence-level craft.

Deep dive into:
1. **Sentence length variance** - monotonous vs dynamic rhythm
2. **Passive density** - overuse of passive voice
3. **Clause stacking** - overly complex nested clauses
4. **Rhythm irregularities** - awkward cadence or flow issues

This is scalpel work, not grammar police. Focus on CRAFT.

Return JSON array with:
- "icon": relevant emoji
- "type": mechanic category
- "message": the specific issue
- "detail": technical explanation and improvement path

Return ONLY valid JSON array.

Chapter text:
${text}`
    }
  ];
  
  const response = await callClaudeForAnalysis(messages, 2500);
  
  try {
    const cleaned = response.replace(/```json|```/g, '').trim();
    return JSON.parse(cleaned);
  } catch (e) {
    throw new Error("Failed to parse mechanics analysis");
  }
}

// ============================================
// DIALOGUE CRITIC
// ============================================
async function handleDialogueCritic({ text }) {
  console.log("ü©∏ Running Dialogue Blade Critic...");
  
  if (!text || text.trim().length === 0) {
    throw new Error("No text provided for analysis");
  }
  
  const messages = [
    {
      role: "user",
      content: `You are a merciless dialogue critic with surgical precision.

Analyze dialogue for:
1. **Voice consistency** - does each character sound distinct?
2. **Power imbalance** - who controls conversations and why
3. **Subtext density** - what's said vs what's meant
4. **On-the-nose alerts** - characters stating emotions directly

Be brutal. No rewrites. Only judgment.

Return JSON array with:
- "icon": dialogue-related emoji
- "type": issue category
- "message": what's wrong
- "detail": why it fails and what it reveals about craft

Return ONLY valid JSON array.

Chapter text:
${text}`
    }
  ];
  
  const response = await callClaudeForAnalysis(messages, 2500);
  
  try {
    const cleaned = response.replace(/```json|```/g, '').trim();
    return JSON.parse(cleaned);
  } catch (e) {
    throw new Error("Failed to parse dialogue analysis");
  }
}

// ============================================
// AI CRITIC MODE
// ============================================
async function handleAICritic({ text, persona }) {
  console.log(`üïØÔ∏è Running AI Critic Mode: ${persona}...`);
  
  if (!text || text.trim().length === 0) {
    throw new Error("No text provided for critique");
  }
  
  const personas = {
    cold_editor: "You are a cold, ruthless editor who has seen thousands of manuscripts. You care about craft, not feelings. Be direct, surgical, and focus on what WORKS and what DOESN'T.",
    market_hawk: "You are a market-savvy publishing hawk who knows what SELLS. Evaluate commercial viability, genre expectations, and reader engagement. Be pragmatic and business-focused.",
    literary_judge: "You are a literary fiction judge who values prose artistry, thematic depth, and narrative innovation. Be intellectual and demanding about craft excellence.",
    dark_romance_gatekeeper: "You are a dark romance gatekeeper who knows the genre inside out. Judge heat levels, power dynamics, emotional stakes, and whether this delivers what readers crave. Be fierce."
  };
  
  const selectedPersona = personas[persona] || personas.cold_editor;
  
  const messages = [
    {
      role: "user",
      content: `${selectedPersona}

Read this chapter and provide your assessment in under 500 words.

Focus on:
- What works
- What doesn't
- Biggest issue to fix
- Overall verdict

NO EDITS. Only assessment.

Return as JSON array with ONE marker:
- "icon": "üé≠"
- "type": "${persona.replace('_', ' ').toUpperCase()}"
- "message": "Overall Assessment"
- "detail": Your full critique (under 500 words)

Return ONLY valid JSON array.

Chapter text:
${text}`
    }
  ];
  
  const response = await callClaudeForAnalysis(messages, 3500);
  
  try {
    const cleaned = response.replace(/```json|```/g, '').trim();
    return JSON.parse(cleaned);
  } catch (e) {
    throw new Error("Failed to parse critic response");
  }
}

// ============================================
// STRUCTURAL INTEGRITY
// ============================================
async function handleStructuralCheck({ text }) {
  console.log("üßø Running Structural Integrity Check...");
  
  if (!text || text.trim().length === 0) {
    throw new Error("No text provided for analysis");
  }
  
  const messages = [
    {
      role: "user",
      content: `You are a structural story architect analyzing narrative integrity.

Examine:
1. **Act alignment** - does structure follow proper story beats?
2. **Promise vs payoff** - are setups resolved satisfyingly?
3. **Foreshadow utilization** - planted elements that pay off
4. **Chekhov violations** - guns on the wall that don't fire

This is architectural, not line-level editing.

Return JSON array with:
- "icon": structure emoji
- "type": structural element
- "message": what's present or missing
- "detail": impact on overall narrative

Return ONLY valid JSON array.

Chapter text:
${text}`
    }
  ];
  
  const response = await callClaudeForAnalysis(messages, 2500);
  
  try {
    const cleaned = response.replace(/```json|```/g, '').trim();
    return JSON.parse(cleaned);
  } catch (e) {
    throw new Error("Failed to parse structural analysis");
  }
}
// ============================================
// TAG JANITOR
// ============================================

async function handleTagGeneration({ name, type }) {
  console.log(`üè∑Ô∏è Generating ${type} tag for: ${name}`);
  
  if (!name || name.trim().length === 0) {
    throw new Error("No name provided for tag generation");
  }
  
  const apiKey = process.env.OPENROUTER_API_KEY;
  
  if (!apiKey) {
    throw new Error("No API key configured");
  }
  
  let prompt;
  if (type === 'character') {
    prompt = `Generate a character tag. Rules: 1) Must start with @, 2) Format: @FirstLast or @FLast if no last name, 3) No spaces, PascalCase, 4) Remove special characters. Name: ${name}. ${existingTags?.length ? `Avoid these existing tags: ${existingTags.join(', ')}` : ''} Return ONLY the tag, nothing else.`;
  } else {
    prompt = `Generate a story tag. Rules: 1) Must start with @, 2) Format: @TitleWithoutSpaces, 3) PascalCase, 4) Keep concise. Title: ${name}. ${existingTags?.length ? `Avoid these existing tags: ${existingTags.join(', ')}` : ''} Return ONLY the tag, nothing else.`;
  }
  
  try {
    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
        'HTTP-Referer': 'https://amygonzalez305.wixsite.com/the-draft-reaper/devil-muse-server',
        'X-Title': 'Devil Muse - Tag Janitor'
      },
      body: JSON.stringify({
        model: "openai/gpt-4.1-mini",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.1, // Very low for consistency
        max_tokens: 50
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Tag generation failed: ${errorText}`);
    }
    
    const data = await response.json();
    const tag = data.choices[0].message.content.trim();
    
    console.log(`‚úÖ Generated tag: ${tag}`);
    return { tag };
    
  } catch (error) {
    console.error(`‚ùå Tag generation error:`, error.message);
    throw error;
  }
}

// ============================================
// START SERVER
// ============================================
const PORT = process.env.PORT || 3333;
app.listen(PORT, () => {
  console.log(`üî• Devil Muse listening on port ${PORT}`);
  console.log(`   Models: ${PRIMARY_MODEL}, ${BACKUP_MODEL}, ${TERTIARY_MODEL}`);
  console.log(`   API Key configured: ${process.env.OPENROUTER_API_KEY ? 'YES ‚úÖ' : 'NO ‚ùå'}`);
});








